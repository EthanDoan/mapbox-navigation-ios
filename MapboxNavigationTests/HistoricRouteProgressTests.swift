import XCTest
import FBSnapshotTestCase
import Turf
import TestHelper
import MapboxDirections
@testable import MapboxCoreNavigation
@testable import MapboxNavigation

struct AssociatedLocation {
    let location: CLLocation
    let text: String
}

class HistoricRouteProgressTests: FBSnapshotTestCase {

    override func setUp() {
        super.setUp()
        recordMode = true
    }

    func testHistoricRouteProgressDisabled() {
        runTest(shouldDiscardHistory: true)
    }
    
    func testHistoricRouteProgressEnabled() {
        runTest(shouldDiscardHistory: false)
    }
    
    func runTest(shouldDiscardHistory: Bool) {
        // Short initial route
        let route = Fixture.route(from: "historic-route-progress")
        // New route from where the trace missed a turn
        let reroute = Fixture.route(from: "historic-route-progress-reroute")
        // Trace of a detour from the initial origin to the destination (generated by `Fixture.generateTrace(for:)`)
        let rawTrace = Fixture.locations(from: "historic-route-progress.trace")
        
        var trace = (rawTrace as [CLLocation?]).enumerated().compactMap { return $0.offset % 2 == 0 ? nil : $0.element }
                                               .enumerated().compactMap { return $0.offset % 2 == 0 ? nil : $0.element }
        trace.append(rawTrace.last!)
        
        
        let directions = DirectionsSpy(accessToken: "foo")
        
        let locationManager = ReplayLocationManager(locations: trace)
        let service = MapboxNavigationService(route: route,
                                              directions: directions,
                                              locationSource: locationManager,
                                              eventsManagerType: NavigationEventsManagerSpy.self,
                                              simulating: SimulationMode.never)
        
        let tester = HistoricProgressTester(navigationService: service, shouldDiscardHistory: shouldDiscardHistory, upcomingRoutes: [reroute])
        
        let view = NavigationPlotter(frame: CGRect(origin: .zero, size: CGSize(width: 1000, height: 1000)))
        view.routePlotters = [RoutePlotter(route: route, color: .route, lineWidth: 8, drawDotIndicator: false, drawTextIndicator: false),
                              RoutePlotter(route: reroute, color: .green, lineWidth: 8, drawDotIndicator: false, drawTextIndicator: false)]
        //view.linePlotters = [LinePlotter(coordinates: trace.map { $0.coordinate }, color: .gray, lineWidth: 4, drawIndexesAsText: false)]
        
        var associatedLocations = [AssociatedLocation]()
        
        for location in trace {
            service.router!.locationManager!(locationManager, didUpdateLocations: [location])
            
            let totalDistanceTraveled = service.router!.routeProgress.totalDistanceTraveled
            let totalFractionTraveled = service.router!.routeProgress.totalFractionTraveled
            let loc = AssociatedLocation.init(location: location, text: "\(Int(totalDistanceTraveled)):\( Double(round(1000*totalFractionTraveled)/1000))")
            associatedLocations.append(loc)
        }
        
        print("!!! \(shouldDiscardHistory) allProgresses \(service.routeProgress.routeProgresses().count)")
        
        view.coordinatePlotters = [CoordinatePlotter(coordinates: associatedLocations.map { $0.location.coordinate },
                                                     coordinateText: associatedLocations.map { $0.text },
                                                     fontSize: 16,
                                                     color: .red,
                                                     drawIndexesAsText: false)]
        
        verify(view)
    }
    
//    func testGenerateNewTrace() {
//        let route = Fixture.route(from: "historic-route-progress")
//
//        // Unpack li.tar
//        let bundle = Bundle(for: Fixture.self)
//        let readonlyPackURL = URL(fileURLWithPath: bundle.path(forResource: "li", ofType: "tar")!)
//        let documentDirectory = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true)[0]
//        let data = try! Data(contentsOf: readonlyPackURL)
//        let packURL = URL(fileURLWithPath: documentDirectory, isDirectory: true).appendingPathComponent(readonlyPackURL.lastPathComponent)
//        try! data.write(to: packURL)
//
//        let outputDirectoryURL = URL(fileURLWithPath: documentDirectory, isDirectory: true).appendingPathComponent("tiles/test")
//        try? FileManager.default.createDirectory(atPath: outputDirectoryURL.path, withIntermediateDirectories: true, attributes: nil)
//
//        var semaphore: DispatchSemaphore? = DispatchSemaphore(value: 0)
//
//        NavigationDirections.unpackTilePack(at: packURL, outputDirectoryURL: outputDirectoryURL, progressHandler: nil) { (result, error) in
//            semaphore!.signal()
//        }
//
//        _ = semaphore!.wait(timeout: DispatchTime.now() + DispatchTimeInterval.seconds(1))
//
//        // Configure router
//        semaphore = DispatchSemaphore(value: 0)
//
//        let directions = NavigationDirections(accessToken: "foo")
//        directions.configureRouter(tilesURL: outputDirectoryURL) { (numberOfTiles) in
//            semaphore!.signal()
//        }
//
//        _ = semaphore!.wait(timeout: DispatchTime.now() + DispatchTimeInterval.seconds(1))
//
//        let coordinates = [route.coordinates!.first!,
//                           CLLocationCoordinate2D(latitude: 47.214263, longitude: 9.522274),
//                           route.coordinates!.last!]
//        let options = NavigationRouteOptions(coordinates: coordinates, profileIdentifier: .automobile)
//
//        //semaphore = DispatchSemaphore(value: 1)
//        let expect = self.expectation(description: "Calculate route expectation")
//        var newRoute: Route? = nil
//        directions.calculate(options, offline: true) { (waypoints, routes, error) in
//            print("1")
//            newRoute = routes!.first!
//            expect.fulfill()
//        }
//
//        self.wait(for: [expect], timeout: 5)
//
//        let newTrace = Fixture.generateTrace(for: newRoute!)
//
//        let encodableTrace = newTrace.map { Location($0) }
//        let encodedTrace = try! JSONEncoder().encode(encodableTrace)
//
//        let string = NSString(string: String(data: encodedTrace, encoding: .utf8)!)
//        print(string)
//        print(".")
//    }
}

class HistoricProgressTester: NavigationServiceDelegate {

    let navigationService: MapboxNavigationService
    let shouldDiscardHistory: Bool
    var upcomingRoutes: [Route]
    
    init(navigationService: MapboxNavigationService, shouldDiscardHistory: Bool, upcomingRoutes: [Route]) {
        self.navigationService = navigationService
        self.shouldDiscardHistory = shouldDiscardHistory
        self.upcomingRoutes = upcomingRoutes
        
        self.navigationService.delegate = self
    }
    
    func navigationServiceShouldDiscardHistory(_ service: NavigationService) -> Bool {
        print("!!! shouldDiscardDelegate: \(shouldDiscardHistory)")
        return shouldDiscardHistory
    }
    
    func navigationService(_ service: NavigationService, shouldRerouteFrom location: CLLocation) -> Bool {
        print("!!! shouldRerouteFrom: \(location)")
        
        navigationService.route = upcomingRoutes.popLast()!
        
        return false
    }
}
